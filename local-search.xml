<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>promise 解决回调地狱的问题</title>
    <link href="/2023/02/18/%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E4%B8%8Epromise/"/>
    <url>/2023/02/18/%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E4%B8%8Epromise/</url>
    
    <content type="html"><![CDATA[<h1 id="promise-解决回调地狱的问题"><a href="#promise-解决回调地狱的问题" class="headerlink" title="promise 解决回调地狱的问题"></a>promise 解决回调地狱的问题</h1><h2 id="一、准备两个事件"><a href="#一、准备两个事件" class="headerlink" title="一、准备两个事件"></a>一、准备两个事件</h2> <figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><br><span class="hljs-comment">//获取奶茶的方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTea</span><span class="hljs-params">(fn)</span> </span>&#123;<br>  setTimeout(() =&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span><span class="hljs-params">(<span class="hljs-string">&quot;喝奶茶&quot;</span>)</span></span><br><span class="hljs-function">  &#125;, 500)</span>;<br>&#125;<br><br><span class="hljs-comment">//获取火锅的方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHotpot</span><span class="hljs-params">(fn)</span> </span>&#123;<br>  setTimeout(() =&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span><span class="hljs-params">(<span class="hljs-string">&quot;吃火锅&quot;</span>)</span></span><br><span class="hljs-function">  &#125;, 1000)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、用回调地狱的方法按自己想要的顺序获取事件"><a href="#二、用回调地狱的方法按自己想要的顺序获取事件" class="headerlink" title="二、用回调地狱的方法按自己想要的顺序获取事件"></a>二、用回调地狱的方法按自己想要的顺序获取事件</h2><h3 id="我们可以看出-因为”吃火锅”定时器事件比-“喝奶茶”定时器事件要长，"><a href="#我们可以看出-因为”吃火锅”定时器事件比-“喝奶茶”定时器事件要长，" class="headerlink" title="我们可以看出 因为”吃火锅”定时器事件比 “喝奶茶”定时器事件要长，"></a>我们可以看出 因为”吃火锅”定时器事件比 “喝奶茶”定时器事件要长，</h3><h3 id="所以”吃火锅”函数要将”喝奶茶”函数包裹在里面，如果继续增加就要层层嵌套形成了回调地狱，不方便维护。"><a href="#所以”吃火锅”函数要将”喝奶茶”函数包裹在里面，如果继续增加就要层层嵌套形成了回调地狱，不方便维护。" class="headerlink" title="所以”吃火锅”函数要将”喝奶茶”函数包裹在里面，如果继续增加就要层层嵌套形成了回调地狱，不方便维护。"></a>所以”吃火锅”函数要将”喝奶茶”函数包裹在里面，如果继续增加就要层层嵌套形成了回调地狱，不方便维护。</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//调用获取火锅的方法</span><br><br>getHotpot(<span class="hljs-function">(<span class="hljs-params">(data</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data);<br><br>  <span class="hljs-comment">//调用获取奶茶的方法</span><br>  getTea(<span class="hljs-function">(<span class="hljs-params">(data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data);<br>  &#125;))<br>&#125;))  <br></code></pre></td></tr></table></figure><h2 id="三、用promise的方法按自己想要的顺序获取事件"><a href="#三、用promise的方法按自己想要的顺序获取事件" class="headerlink" title="三、用promise的方法按自己想要的顺序获取事件"></a>三、用promise的方法按自己想要的顺序获取事件</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">###先<span class="hljs-keyword">new</span>一个 <span class="hljs-string">&quot;喝奶茶&quot;</span> 的Promise，<br> <span class="hljs-keyword">function</span> get<span class="hljs-constructor">Tea()</span> &#123;<br>   return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span> (<span class="hljs-params">resolve</span>)</span> &#123;<br>     set<span class="hljs-constructor">Timeout(()</span> =&gt; &#123;<br>       resolve(<span class="hljs-string">&quot;喝奶茶&quot;</span>)<br>     &#125;, <span class="hljs-number">500</span>)<br>   &#125;)<br><br> &#125;<br></code></pre></td></tr></table></figure><h3 id="再new一个-“吃火锅”-的Promise，"><a href="#再new一个-“吃火锅”-的Promise，" class="headerlink" title="再new一个 “吃火锅” 的Promise，"></a>再new一个 “吃火锅” 的Promise，</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getHotpot</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;吃火锅&quot;</span>)<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-用-then-的方法获取数据–链式操作"><a href="#1-用-then-的方法获取数据–链式操作" class="headerlink" title="1.用 .then 的方法获取数据–链式操作"></a>1.用 .then 的方法获取数据–链式操作</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">getHotpot().then(<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data); <span class="hljs-comment">//这是吃火锅的数据</span><br><br>  <span class="hljs-keyword">return</span> getTea()<br>&#125;).then(<span class="hljs-keyword">function</span> (<span class="hljs-params">date</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">date</span>); <span class="hljs-comment">//这是喝奶茶的数据</span><br>    <br>&#125;) */<br></code></pre></td></tr></table></figure><h3 id="2-用async-函数调用-更精简，看起来像是同步的。"><a href="#2-用async-函数调用-更精简，看起来像是同步的。" class="headerlink" title="2.用async 函数调用 更精简，看起来像是同步的。"></a>2.用async 函数调用 更精简，看起来像是同步的。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-comment">//直接获取 resolve 传过来的数据</span><br>  <span class="hljs-keyword">let</span> hotPot = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getHotpot</span>(); <span class="hljs-comment">//吃火锅</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hotPot);<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-title class_">Tea</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getTea</span>(); <span class="hljs-comment">//喝奶茶</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Tea</span>);<br>&#125;<br><br><span class="hljs-comment">//调用getData函数</span><br><span class="hljs-title function_">getData</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>telescope</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>节流防抖案例</title>
    <link href="/2023/02/17/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E6%A1%88%E5%88%97/"/>
    <url>/2023/02/17/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E6%A1%88%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="防抖-（多次触发-只执行最后一次）"><a href="#防抖-（多次触发-只执行最后一次）" class="headerlink" title="防抖 （多次触发 只执行最后一次）"></a>防抖 （多次触发 只执行最后一次）</h1><h2 id="逻辑：-高频率触发的事件-在指定的单位时间内，只响应最后一次，如果在指定的时间内再次触发，则重新计算时间"><a href="#逻辑：-高频率触发的事件-在指定的单位时间内，只响应最后一次，如果在指定的时间内再次触发，则重新计算时间" class="headerlink" title="逻辑： 高频率触发的事件,在指定的单位时间内，只响应最后一次，如果在指定的时间内再次触发，则重新计算时间"></a>逻辑： 高频率触发的事件,在指定的单位时间内，只响应最后一次，如果在指定的时间内再次触发，则重新计算时间</h2><h2 id="防抖类似于英雄联盟回城6秒，如果回城中被打断，再次回城需要再等6秒-如：搜索框搜索输入"><a href="#防抖类似于英雄联盟回城6秒，如果回城中被打断，再次回城需要再等6秒-如：搜索框搜索输入" class="headerlink" title="防抖类似于英雄联盟回城6秒，如果回城中被打断，再次回城需要再等6秒 (如：搜索框搜索输入)"></a>防抖类似于英雄联盟回城6秒，如果回城中被打断，再次回城需要再等6秒 (如：搜索框搜索输入)</h2><h3 id="style-部分代码"><a href="#style-部分代码" class="headerlink" title="style 部分代码"></a>style 部分代码</h3>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>:skyblue;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="div-部分代码"><a href="#div-部分代码" class="headerlink" title="div 部分代码"></a>div 部分代码</h3> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="scrip-t部分代码"><a href="#scrip-t部分代码" class="headerlink" title="scrip t部分代码"></a>scrip t部分代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//获取元素</span><br><span class="hljs-keyword">let</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;input&#x27;</span>)[<span class="hljs-number">0</span>]<br><span class="hljs-comment">//防抖</span><br><span class="hljs-keyword">let</span> timerId = <span class="hljs-literal">null</span><br>input.<span class="hljs-property">onkeyup</span> =<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-keyword">if</span> (timerId !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timerId)<br>  &#125;<br>  timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;防抖&quot;</span>);<br>  &#125;, <span class="hljs-number">2000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-节流-（规定时间内-只触发一次）"><a href="#2-节流-（规定时间内-只触发一次）" class="headerlink" title="2.节流 （规定时间内 只触发一次）"></a>2.节流 （规定时间内 只触发一次）</h1><h2 id="逻辑：-高频率触发的事件-在指定的单位时间内，只响应第一次"><a href="#逻辑：-高频率触发的事件-在指定的单位时间内，只响应第一次" class="headerlink" title="逻辑： 高频率触发的事件,在指定的单位时间内，只响应第一次"></a>逻辑： 高频率触发的事件,在指定的单位时间内，只响应第一次</h2><h2 id="节流类似于英雄联盟里的英雄平A-一定是内点击多次只进行攻击一次-如：搜索框搜索输入"><a href="#节流类似于英雄联盟里的英雄平A-一定是内点击多次只进行攻击一次-如：搜索框搜索输入" class="headerlink" title="节流类似于英雄联盟里的英雄平A   一定是内点击多次只进行攻击一次 (如：搜索框搜索输入)"></a>节流类似于英雄联盟里的英雄平A   一定是内点击多次只进行攻击一次 (如：搜索框搜索输入)</h2><h3 id="script-部分代码"><a href="#script-部分代码" class="headerlink" title="script 部分代码"></a>script 部分代码</h3> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//获取元素</span><br><span class="hljs-keyword">let</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>]<br><span class="hljs-comment">//节流</span><br><span class="hljs-keyword">let</span> timerout = <span class="hljs-number">0</span><br>div.<span class="hljs-property">onmousemove</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (timerout !== <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  timerout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;节流&quot;</span>);<br>    timerout = <span class="hljs-number">0</span><br>  &#125;, <span class="hljs-number">2000</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>telescope</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fliter+indexOf 数组去重</title>
    <link href="/2023/02/17/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <url>/2023/02/17/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="一-去掉重复的留下相同的，返回一个新的数组。"><a href="#一-去掉重复的留下相同的，返回一个新的数组。" class="headerlink" title="一.去掉重复的留下相同的，返回一个新的数组。"></a>一.去掉重复的留下相同的，返回一个新的数组。</h1><h2 id="逻辑："><a href="#逻辑：" class="headerlink" title="逻辑："></a>逻辑：</h2><h3 id="1-filter-过滤数组，会根据条件返回新的数组（两个数组指向同一个内存属于浅拷贝）"><a href="#1-filter-过滤数组，会根据条件返回新的数组（两个数组指向同一个内存属于浅拷贝）" class="headerlink" title="1.filter() 过滤数组，会根据条件返回新的数组（两个数组指向同一个内存属于浅拷贝）"></a>1.filter() 过滤数组，会根据条件返回新的数组（两个数组指向同一个内存属于浅拷贝）</h3><h3 id="2-indexOf-会返回当前数字-首次-出现的索引"><a href="#2-indexOf-会返回当前数字-首次-出现的索引" class="headerlink" title="2.indexOf() 会返回当前数字 首次 出现的索引"></a>2.indexOf() 会返回当前数字 首次 出现的索引</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let arr = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, ]<br>   <br>let arry = arr.<span class="hljs-built_in">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, i</span>) =&gt;</span><br>  <br>  arr.<span class="hljs-built_in">indexOf</span>(item) === i<br>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arry);<br><br><span class="hljs-comment">//arry[[1, 4, 5, 8, 2, 3,6]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>telescope</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10s支付跳转案例</title>
    <link href="/2023/02/15/10s%E6%94%AF%E4%BB%98%E8%B7%B3%E8%BD%AC%E6%A1%88%E4%BE%8B/"/>
    <url>/2023/02/15/10s%E6%94%AF%E4%BB%98%E8%B7%B3%E8%BD%AC%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一-这是点击跳转的页面代码"><a href="#一-这是点击跳转的页面代码" class="headerlink" title="一.这是点击跳转的页面代码"></a>一.这是点击跳转的页面代码</h2><h3 id="逻辑：获取支付的-button-按钮，绑定一个-onclick-点击事件，绑定一个跳转页面，如果点击支付就判断为真就跳转到相应页面"><a href="#逻辑：获取支付的-button-按钮，绑定一个-onclick-点击事件，绑定一个跳转页面，如果点击支付就判断为真就跳转到相应页面" class="headerlink" title="逻辑：获取支付的 button 按钮，绑定一个 onclick 点击事件，绑定一个跳转页面，如果点击支付就判断为真就跳转到相应页面"></a>逻辑：获取支付的 button 按钮，绑定一个 onclick 点击事件，绑定一个跳转页面，如果点击支付就判断为真就跳转到相应页面</h3><h3 id="style-部分代码"><a href="#style-部分代码" class="headerlink" title="style 部分代码"></a>style 部分代码</h3><pre><code class="hljs">    div &#123;        width: 200px;        height: 280px;        background-color: #999;        padding: 20px;        margin: 0 auto;        text-align: center;    &#125;    button &#123;        margin: 25px 15px;    &#125;      </code></pre><h3 id="div-部分代码"><a href="#div-部分代码" class="headerlink" title="div 部分代码"></a>div 部分代码</h3><pre><code class="hljs">  &lt;p&gt;商品： wed前端课程&lt;/p&gt;    &lt;p&gt;价格： 198元&lt;/p&gt;    &lt;p&gt;内容： HTML·css ·js&lt;/p&gt;    &lt;p&gt;地址： 广州白云区&lt;/p&gt;    &lt;p&gt;        &lt;button&gt;取消&lt;/button&gt;        &lt;button&gt;支付&lt;/button&gt;    &lt;/p&gt;</code></pre><h3 id="x2F-x2F-逻辑：点击支付，出现确认"><a href="#x2F-x2F-逻辑：点击支付，出现确认" class="headerlink" title="&#x2F;&#x2F;逻辑：点击支付，出现确认"></a>&#x2F;&#x2F;逻辑：点击支付，出现确认</h3><h3 id="script-部分代码"><a href="#script-部分代码" class="headerlink" title="script 部分代码"></a>script 部分代码</h3><pre><code class="hljs">  document.getElementsByTagName(&#39;button&#39;)[1].onclick = function () &#123;        let res = window.confirm(&#39;您确定要支付吗？&#39;);        if (res) &#123;            location.href = &#39;./跳转页面.html&#39;        &#125;    &#125;</code></pre><h2 id="二-这是跳转页面的代码"><a href="#二-这是跳转页面的代码" class="headerlink" title="二.这是跳转页面的代码"></a>二.这是跳转页面的代码</h2><h3 id="逻辑：加载页面时，触发定时器倒计时-10s，绑定链接-10s-后自动跳转相应页面。也可以直接点击立即跳转按钮，进行跳转。"><a href="#逻辑：加载页面时，触发定时器倒计时-10s，绑定链接-10s-后自动跳转相应页面。也可以直接点击立即跳转按钮，进行跳转。" class="headerlink" title="逻辑：加载页面时，触发定时器倒计时 10s，绑定链接 10s 后自动跳转相应页面。也可以直接点击立即跳转按钮，进行跳转。"></a>逻辑：加载页面时，触发定时器倒计时 10s，绑定链接 10s 后自动跳转相应页面。也可以直接点击立即跳转按钮，进行跳转。</h3><h3 id="style部分代码"><a href="#style部分代码" class="headerlink" title="style部分代码"></a>style部分代码</h3><pre><code class="hljs">    .one &#123;        width: 500px;        padding: 20px;        margin: 0 auto;    &#125;    .one span &#123;        font-size: 30px;        color: red;    &#125;     </code></pre><h3 id="div-部分代码-1"><a href="#div-部分代码-1" class="headerlink" title="div 部分代码"></a>div 部分代码</h3><pre><code class="hljs">&lt;div class=&quot;one&quot;&gt;    &lt;h1&gt;恭喜您，支付成功&lt;/h1&gt;    &lt;span&gt;10&lt;/span&gt;秒后自动返回首页    &lt;p&gt; &lt;button&gt;立即返回&lt;/button&gt;&lt;/p&gt;&lt;/div&gt;</code></pre><h3 id="script-部分代码-1"><a href="#script-部分代码-1" class="headerlink" title="script 部分代码"></a>script 部分代码</h3><h4 id="逻辑：加载页面时，触发定时器-10s"><a href="#逻辑：加载页面时，触发定时器-10s" class="headerlink" title="逻辑：加载页面时，触发定时器 10s"></a>逻辑：加载页面时，触发定时器 10s</h4><pre><code class="hljs">    window.onload = function () &#123;        let timer = 10;        setInterval(() =&gt; &#123;            timer--;            document.getElementsByTagName(&#39;span&#39;)[0].innerHTML = timer;            if (timer == 0) &#123;                location.href = &#39;https://www.runoob.com/w3c/w3c-tutorial.html&#39;;            &#125;        &#125;, 1000)    &#125;    document.getElementsByTagName(&#39;button&#39;)[0].onclick = function () &#123;        location.href = &#39;https://www.runoob.com/w3c/w3c-tutorial.html&#39;;    &#125;    </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>telescope</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax请求的五个步骤</title>
    <link href="/2022/09/04/Ajax%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BA%94%E4%B8%AA%E6%AD%A5%E9%AA%A4/"/>
    <url>/2022/09/04/Ajax%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BA%94%E4%B8%AA%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<ul><li><p>——Ajax简介——：ajax即异步 JavaScript 和XML。Ajax是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。而传统的网页(不使用 Ajax)如果需要更新内容，必需重载整个网页面。</p></li><li><p>ajax的工作原理：客户端发送请求，请求交给xhr，xhr把请求提交给服务，服务器进行业务处理，服务器响应数据交给xhr对象，xhr对象接收数据，由javascript把数据写到页面上</p></li></ul><h3 id="实现AJAX的基本步骤："><a href="#实现AJAX的基本步骤：" class="headerlink" title="实现AJAX的基本步骤："></a>实现AJAX的基本步骤：</h3><ul><li>要完整实现一个AJAX异步调用和局部刷新,通常需要以下几个步骤:</li></ul><ol><li>创建XMLHttpRequest对象,即创建一个异步调用对象。</li><li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息。</li><li>设置响应HTTP请求状态变化的函数。</li><li>发送HTTP请求。</li><li>获取异步调用返回的数据。</li><li>使用JavaScript和DOM实现局部刷新。</li></ol><h3 id="一-创建XMLHttpRequest对象"><a href="#一-创建XMLHttpRequest对象" class="headerlink" title="一.创建XMLHttpRequest对象"></a>一.创建XMLHttpRequest对象</h3><ol><li>不同浏览器使用的异步调用对象有所不同，在IE浏览器中异步调用使用的是XMLHTTP组件中的XMLHttpRequest对象，而在Netscape、Firefox浏览器中则直接使用XMLHttpRequest组件。因此，在不同浏览器中创建XMLHttpRequest对象的方式都有所不同。</li></ol><ul><li><p>在IE浏览器中创建XMLHttpRequest对象的方式为:<br> var xmlHttpRequest &#x3D; new ActiveXObject(“Microsoft.XMLHTTP”);</p></li><li><p>在Netscape浏览器中创建XMLHttpRequest对象的方式为:</p></li></ul><p>var xmlHttpRequest &#x3D; new XMLHttpRequest();</p><p><strong>由于无法确定用户使用的是什么浏览器,所以在创建XMLHttpRequest对象时,最好将以上两种方法都加上.如以下代码所示:</strong></p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby">var xmlHttpRequest;  <span class="hljs-regexp">//</span>定义一个变量,用于存放XMLHttpRequest对象<br>   createXMLHttpRequst();   <span class="hljs-regexp">//</span>调用创建对象的方法<br>   /<span class="hljs-regexp">/创建XMLHttpRequest对象的方法 </span><br><span class="hljs-regexp">   function createXMLHttpRequest()&#123;                                                 </span><br><span class="hljs-regexp">       if(window.ActiveXObject) &#123;/</span><span class="hljs-regexp">/判断是否是IE浏览器</span><br><span class="hljs-regexp">           xmlHttpRequest = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);/</span><span class="hljs-regexp">/创建IE的XMLHttpRequest对象</span><br><span class="hljs-regexp">       &#125;else if(window.XMLHttpRequest)&#123;/</span><span class="hljs-regexp">/判断是否是Netscape等其他支持XMLHttpRequest组件的浏览器</span><br><span class="hljs-regexp">           xmlHttpRequest = new XMLHttpRequest();/</span><span class="hljs-regexp">/创建其他浏览器上的XMLHttpRequest对象</span><br><span class="hljs-regexp">       &#125;</span><br><span class="hljs-regexp">   &#125; </span><br></code></pre></td></tr></table></figure><ol><li><p>“if(window.ActiveXObject)”用来判断是否使用IE浏览器.其中ActiveXOject并不是Windows对象的标准属性,而是IE浏览器中专有的属性,可以用于判断浏览器是否支持ActiveX控件.通常只有IE浏览器或以IE浏览器为核心的浏览器才能支持Active控件.</p></li><li><p>“else if(window.XMLHttpRequest)”是为了防止一些浏览器既不支持ActiveX控件,也不支持XMLHttpRequest组件而进行的判断.其中XMLHttpRequest也不是window对象的标准属性,但可以用来判断浏览器是否支持XMLHttpRequest组件.</p></li><li><p>如果浏览器既不支持ActiveX控件,也不支持XMLHttpRequest组件,那么就不会对xmlHttpRequest变量赋值.</p></li></ol><h3 id="二-创建HTTP请求"><a href="#二-创建HTTP请求" class="headerlink" title="二.创建HTTP请求"></a>二.创建HTTP请求</h3><ol><li>创建了XMLHttpRequest对象之后，必须为XMLHttpRequest对象创建HTTP请求，用于说明XMLHttpRequest对象要从哪里获取数据。通常可以是网站中的数据,也可以是本地中其他文件中的数据。<br><strong>创建HTTP请求可以使用XMLHttpRequest对象的open()方法,其语法代码如下所示:</strong></li></ol><ul><li><p>method：该参数用于指定HTTP的请求方法，一共有get、post、head、put、delete五种方法，常用的方法为get和post。</p></li><li><p>URL：该参数用于指定HTTP请求的URL地址，可以是绝对URL，也可以是相对URL。</p></li><li><p>flag：该参数为可选，参数值为布尔型。该参数用于指定是否使用异步方式。true表示异步、false表示同步，默认为true。</p></li><li><p>name：该参数为可选参数，用于输入用户名。如果服务器需要验证，则必须使用该参数。</p></li><li><p>password：该参数为可选，用于输入密码。若服务器需要验证，则必须使用该参数。</p></li></ul><ol><li>通常可以使用以下代码来访问一个网站文件的内容。</li></ol><p>xmlHttpRequest.open(“get”,”<a href="http://www.aspxfans.com/BookSupport/JavaScript/ajax.htm&quot;,true">http://www.aspxfans.com/BookSupport/JavaScript/ajax.htm&quot;,true</a>);</p><ol start="3"><li>或者使用以下代码来访问一个本地文件内容：</li></ol><p>xmlHttpRequest.open(“get”,”ajax.htm”,true);</p><ul><li>注意：如果HTML文件放在Web服务器上，在Netscape浏览器中的JavaScript安全机制不允许与本机之外的主机进行通信。也就是说，使用open()方法只能打开与HTML文件在同一个服务器上的文件。而在IE浏览器中则无此限制（虽然可以打开其他服务器上的文件，但也会有警告提示）。</li></ul><h3 id="三-设置响应HTTP请求状态变化的函数"><a href="#三-设置响应HTTP请求状态变化的函数" class="headerlink" title="三.设置响应HTTP请求状态变化的函数"></a>三.设置响应HTTP请求状态变化的函数</h3><ol><li>创建完HTTP请求之后，应该就可以将HTTP请求发送给Web服务器了。然而，发送HTTP请求的目的是为了接收从服务器中返回的数据。从创建XMLHttpRequest对象开始，到发送数据、接收数据、XMLHttpRequest对象一共会经历以下5中状态。</li><li></li></ol><ul><li>未初始化状态。在创建完XMLHttpRequest对象时，该对象处于未初始化状态，此时XMLHttpRequest对象的readyState属性值为0。</li><li>初始化状态。在创建完XMLHttpRequest对象后使用open()方法创建了HTTP请求时，该对象处于初始化状态。此时XMLHttpRequest对象的readyState属性值为1。</li><li>发送数据状态。在初始化XMLHttpRequest对象后，使用send()方法发送数据时，该对象处于发送数据状态，此时XMLHttpRequest对象的readyState属性值为2。</li><li>接收数据状态。Web服务器接收完数据并进行处理完毕之后，向客户端传送返回的结果。此时，XMLHttpRequest对象处于接收数据状态，XMLHttpRequest对象的readyState属性值为3。</li><li>完成状态。XMLHttpRequest对象接收数据完毕后，进入完成状态，此时XMLHttpRequest对象的readyState属性值为4。此时接收完毕后的数据存入在客户端计算机的内存中，可以使用responseText属性或responseXml属性来获取数据。</li></ul><ol start="3"><li><p>只有在XMLHttpRequest对象完成了以上5个步骤之后，才可以获取从服务器端返回的数据。因此，如果要获得从服务器端返回的数据，就必须要先判断XMLHttpRequest对象的状态。</p></li><li><p>XMLHttpRequest对象可以响应readystatechange事件，该事件在XMLHttpRequest对象状态改变时（也就是readyState属性值改变时）激发。因此，可以通过该事件调用一个函数，并在该函数中判断XMLHttpRequest对象的readyState属性值。如果readyState属性值为4则使用responseText属性或responseXml属性来获取数据。具体代码如下所示：</p><p> &#x2F;&#x2F;设置当XMLHttpRequest对象状态改变时调用的函数，注意函数名后面不要添加小括号<br> xmlHttpRequest.onreadystatechange &#x3D; getData;</p><p> &#x2F;&#x2F;定义函数<br> function getData(){<br> &#x2F;&#x2F;判断XMLHttpRequest对象的readyState属性值是否为4，如果为4表示异步调用完成<br> if(xmlHttpRequest.readyState &#x3D;&#x3D; 4) {<br>     &#x2F;&#x2F;设置获取数据的语句<br> }<br> }</p></li></ol><h3 id="四-设置获取服务器返回数据的语句"><a href="#四-设置获取服务器返回数据的语句" class="headerlink" title="四.设置获取服务器返回数据的语句"></a>四.设置获取服务器返回数据的语句</h3><ol><li><p>如果XMLHttpRequest对象的readyState属性值等于4，表示异步调用过程完毕，就可以通过XMLHttpRequest对象的responseText属性或responseXml属性来获取数据。</p></li><li><p>但是，异步调用过程完毕，并不代表异步调用成功了，如果要判断异步调用是否成功，还要判断XMLHttpRequest对象的status属性值，只有该属性值为200，才表示异步调用成功，因此，要获取服务器返回数据的语句，还必须要先判断XMLHttpRequest对象的status属性值是否等于200，<br>  <strong>如以下代码所示：</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">if</span>(xmlHttpRequst.status == <span class="hljs-number">200</span>) &#123;<br>   document.write(xmlHttpRequest.responseText);<span class="hljs-regexp">//</span>将返回结果以字符串形式输出<br>   /<span class="hljs-regexp">/document.write(xmlHttpRequest.responseXML);/</span><span class="hljs-regexp">/或者将返回结果以XML形式输出</span><br><span class="hljs-regexp">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>注意：如果HTML文件不是在Web服务器上运行，而是在本地运行，则xmlHttpRequest.status的返回值为0。因此，如果该文件在本地运行，则应该加上xmlHttpRequest.status &#x3D;&#x3D; 0的判断。</p></li></ol><p><strong>通常将以上代码放在响应HTTP请求状态变化的函数体内，如以下代码所示</strong>       </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">/设置当XMLHttpRequest对象状态改变时调用的函数，注意函数名后面不要添加小括号</span><br><span class="hljs-regexp">xmlHttpRequest.onreadystatechange = getData;</span><br><span class="hljs-regexp"> </span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">/定义函数</span><br><span class="hljs-regexp">function getData()&#123;</span><br><span class="hljs-regexp">    /</span><span class="hljs-regexp">/判断XMLHttpRequest对象的readyState属性值是否为4，如果为4表示异步调用完成</span><br><span class="hljs-regexp">    if(xmlHttpRequest.readyState==4)&#123;</span><br><span class="hljs-regexp">        if(xmlHttpRequest.status == 200 || xmlHttpRequest.status == 0)&#123;/</span><span class="hljs-regexp">/设置获取数据的语句</span><br><span class="hljs-regexp">            document.write(xmlHttpRequest.responseText);/</span><span class="hljs-regexp">/将返回结果以字符串形式输出</span><br><span class="hljs-regexp">            /</span><span class="hljs-regexp">/docunment.write(xmlHttpRequest.responseXML);/</span><span class="hljs-regexp">/或者将返回结果以XML形式输出</span><br><span class="hljs-regexp">        &#125;</span><br><span class="hljs-regexp">    &#125;</span><br><span class="hljs-regexp">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="五-发送HTTP请求"><a href="#五-发送HTTP请求" class="headerlink" title="五.发送HTTP请求"></a>五.发送HTTP请求</h3><ol><li>在经过以上几个步骤的设置之后，就可以将HTTP请求发送到Web服务器上去了。发送HTTP请求可以使用XMLHttpRequest对象的send()方法。</li></ol><p>___ 其语法代码如下所示：__</p><p>XMLHttpRequest.send(data);</p><ol start="2"><li>其中data是个可选参数，如果请求的数据不需要参数，即可以使用null来替代。data参数的格式与在URL中传递参数的格式类似，以下代码为一个send()方法中的data参数的示例：</li></ol><p>name&#x3D;myName&amp;value&#x3D;myValue</p><ol start="3"><li>只有在使用send()方法之后，XMLHttpRequest对象的readyState属性值才会开始改变，也才会激发readystatechange事件，并调用函数。</li></ol><h3 id="六-局部更新"><a href="#六-局部更新" class="headerlink" title="六.局部更新"></a>六.局部更新</h3><ol><li>在通过Ajax的异步调用获得服务器端数据之后，可以使用JavaScript或DOM来将网页中的数据进行局部更新。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>从输入URL到浏览器显示页面发生过程</title>
    <link href="/2022/09/02/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/09/02/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><ul><li>互联网内各网络设备间的通信都遵循TCP&#x2F;IP协议，利用TCP&#x2F;IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层网上走。·</li></ul><h2 id="一、在浏览器中输入url"><a href="#一、在浏览器中输入url" class="headerlink" title="一、在浏览器中输入url"></a>一、在浏览器中输入url</h2><ol><li>用户输入url，例如<a href="http://www.baidu.com.其中http为协议,www.baidu.com为网络地址,及指出需要的资源在那台计算机上./">http://www.baidu.com。其中http为协议，www.baidu.com为网络地址，及指出需要的资源在那台计算机上。</a></li><li>一般网络地址可以称为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。</li></ol><h2 id="二、-应用层DNS解析域名"><a href="#二、-应用层DNS解析域名" class="headerlink" title="二、 应用层DNS解析域名"></a>二、 应用层DNS解析域名</h2><ol><li>客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到或到根节点。</li></ol><h2 id="三、-应用层客户端发送HTTP请求"><a href="#三、-应用层客户端发送HTTP请求" class="headerlink" title="三、 应用层客户端发送HTTP请求"></a>三、 应用层客户端发送HTTP请求</h2><ol><li>HTTP请求包括请求报头和请求主体两个部分，其中请求报头包含了至关重要的信息，包括请求的方法（GET &#x2F; POST）、目标url、遵循的协议（http &#x2F; https &#x2F; ftp…），返回的信息是否需要缓存，以及客户端是否发送cookie等。</li></ol><h2 id="四、-传输层TCP传输报文（三次握手）"><a href="#四、-传输层TCP传输报文（三次握手）" class="headerlink" title="四、 传输层TCP传输报文（三次握手）"></a>四、 传输层TCP传输报文（三次握手）</h2><ol><li>位于传输层的TCP协议为传输报文提供可靠的字节流服务。它为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。</li><li>“三次握手”的过程是，发送端先发送一个带有SYN（synchronize）标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN&#x2F;ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有ACK标志的数据包给接收端以示握手成功。</li><li>在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。</li></ol><h2 id="五、-网络层IP协议查询MAC地址"><a href="#五、-网络层IP协议查询MAC地址" class="headerlink" title="五、 网络层IP协议查询MAC地址"></a>五、 网络层IP协议查询MAC地址</h2><ol><li>IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。</li><li>IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。</li><li>当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。</li></ol><h2 id="六、-数据到达数据链路层"><a href="#六、-数据到达数据链路层" class="headerlink" title="六、 数据到达数据链路层"></a>六、 数据到达数据链路层</h2><ol><li>在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束。</li></ol><h2 id="七、-服务器接收数据"><a href="#七、-服务器接收数据" class="headerlink" title="七、 服务器接收数据"></a>七、 服务器接收数据</h2><ol><li>接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议讲分段的数据包重新组成原来的HTTP请求报文。</li></ol><h2 id="八、-服务器响应请求"><a href="#八、-服务器响应请求" class="headerlink" title="八、 服务器响应请求"></a>八、 服务器响应请求</h2><ol><li>服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码。</li><li>状态码由三位数字组成，其中比较常见的是200 OK表示请求成功。301表示永久重定向，即请求的资源已经永久转移到新的位置。</li><li>在返回301状态码的同时，响应报文也会附带重定向的url，客户端接收到后将http请求的url做相应的改变再重新发送。404 not found 表示客户端请求的资源找不到。</li></ol><h2 id="九、-服务器返回相应文件"><a href="#九、-服务器返回相应文件" class="headerlink" title="九、 服务器返回相应文件"></a>九、 服务器返回相应文件</h2><ol><li>请求成功后，服务器会返回相应的HTML文件。接下来就到了页面的渲染阶段了。</li></ol><h1 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h1><ol><li>现代浏览器渲染页面的过程是这样的：解析HTML以构建DOM树 –&gt; 构建渲染树 –&gt; 布局渲染树 –&gt; 绘制渲染树。</li><li>DOM树是由HTML文件中的标签排列组成，渲染树是在DOM树中加入CSS或HTML中的style样式而形成。渲染树只包含需要显示在页面中的DOM元素，像元素或display属性值为none的元素都不在渲染树中。</li><li>在浏览器还没接收到完整的HTML文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送HTTP请求重复上述的步骤。</li><li>在收到CSS文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。</li></ol><ul><li>最后总结一下：</li></ul><ol><li>在浏览器客户端输入url后，url分为http协议和域名，先根据域名在本地查找是否有该域名对应的ip地址记录，如果没有则去DNS服务器上查找，查找到后浏览器正式发送http请求，请求到达传输层后，由于tcp协议，为了方便传输，将大块的数据分割成报文段为单位的数据包进行管理。接着就进行大家耳熟能详的三次握手建立连接的过程了。</li><li>连接建立后数据包就会被传输到网络层，ARP协议可以将IP地址解析成对应的MAC地址，如果在不同网段会经过多次中转才能找到。找到物理地址后就会发送数据包到数据链路层，服务器在数据链路层接收到数据包，请求结束，进入服务器应答阶段。</li><li>服务器将接收的数据包传递至传输层，将小块数据包重新组成原来的http请求报文。将http请求报文传递到服务器后，服务器对报文进行解析，并处理请求。无论成功与否，都会返回对应状态码，如果请求成功，还会返回相应的html文件。层层传递之后，应答被浏览器接收到，浏览器对html文件进行DOM树渲染，渲染后呈现的就是我们看到的页面了。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>三次握手和四次挥手</title>
    <link href="/2022/08/30/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/2022/08/30/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><ul><li><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p></li><li><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。<br>进行三次握手：</p></li></ul><h3 id="第一次握手："><a href="#第一次握手：" class="headerlink" title="第一次握手："></a>第一次握手：</h3><ol><li><p>客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SENT 状态。</p><p> 首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</p></li></ol><h3 id="第二次握手："><a href="#第二次握手：" class="headerlink" title="第二次握手："></a>第二次握手：</h3><ol><li><p>服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。</p></li><li><p>同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。</p></li><li><p>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。</p></li></ol><h3 id="第三次握手："><a href="#第三次握手：" class="headerlink" title="第三次握手："></a>第三次握手：</h3><ol><li><p>客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。</p></li><li><p>服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p></li><li><p>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p></li><li><p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。<br>在socket编程中，客户端执行connect()时，将触发三次握手。</p></li></ol><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><ul><li><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p></li><li><p>TCP 连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务端均可主动发起挥手动作。</p></li><li><p>刚开始双方都处于ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p></li></ul><h3 id="第一次挥手："><a href="#第一次挥手：" class="headerlink" title="第一次挥手："></a>第一次挥手：</h3><ol><li>客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li><li>即发出连接释放报文段（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</li></ol><h3 id="第二次挥手："><a href="#第二次挥手：" class="headerlink" title="第二次挥手："></a>第二次挥手：</h3><ol><li>服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</li><li>即服务端收到连接释放报文段后即发出确认报文段（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。</li><li>客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</li></ol><h3 id="第三次挥手："><a href="#第三次挥手：" class="headerlink" title="第三次挥手："></a>第三次挥手：</h3><ol><li>如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li><li>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</li></ol><h3 id="第四次挥手："><a href="#第四次挥手：" class="headerlink" title="第四次挥手："></a>第四次挥手：</h3><ol><li>客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。</li><li>需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li><li>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vue 的生命周期</title>
    <link href="/2022/08/30/vue%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/08/30/vue%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<ul><li>生命周期是指 vue 实例对象从创建之初到销毁的过程，vue 的所有功能都是围绕生命周期进行的，在生命周期的不同阶段调用不同的钩子函数来实现组建的数据管理和DOM渲染。</li></ul><h2 id="一、创建前（beforeCreate）"><a href="#一、创建前（beforeCreate）" class="headerlink" title="一、创建前（beforeCreate）"></a>一、创建前（beforeCreate）</h2><ol><li>此阶段为实例化初始后，此时数据观察和事件机制都没有形成，不能获取 DOM 节点。</li></ol><h2 id="二、-创建后（created）"><a href="#二、-创建后（created）" class="headerlink" title="二、 创建后（created）"></a>二、 创建后（created）</h2><ol><li>在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch&#x2F;event事件回调，完成了data 数据的初始化，$el还没有。</li><li>然而，挂载阶段还没有开始, $el属性目前不可见，这是一个常用的生命周期，因为你可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，，获取    computed中的计算属性等等。</li><li>通常我们可以在这里对实例进行预处理，也有一些人喜欢在这里发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter中完成比较好。</li></ol><h2 id="三、载入前（beforeMount）"><a href="#三、载入前（beforeMount）" class="headerlink" title="三、载入前（beforeMount）"></a>三、载入前（beforeMount）</h2><ol><li>挂载开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意的是此时还没有挂在html到页面上。</li></ol><h2 id="四、载入后（mounted）"><a href="#四、载入后（mounted）" class="headerlink" title="四、载入后（mounted）"></a>四、载入后（mounted）</h2><ol><li>挂载完成，也就是模板中的HTML渲染到页面中，此时一般可以做一些ajax操作，mounted只会执行一次。</li></ol><h2 id="五、更新前（beforeUpdate）"><a href="#五、更新前（beforeUpdate）" class="headerlink" title="五、更新前（beforeUpdate）"></a>五、更新前（beforeUpdate）</h2><ol><li>在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子函数中进一步地更改状态，不会触发附加的重复渲染过程。</li></ol><h2 id="六、更新后（updated）"><a href="#六、更新后（updated）" class="headerlink" title="六、更新后（updated）"></a>六、更新后（updated）</h2><ol><li>当data中定义的数据有变化时就会加载updated方法。</li></ol><h2 id="七、销毁前（beforeDestroy）"><a href="#七、销毁前（beforeDestroy）" class="headerlink" title="七、销毁前（beforeDestroy）"></a>七、销毁前（beforeDestroy）</h2><ol><li>这一步还可以用this来获取实例，一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的dom事件等。</li></ol><h2 id="八、销毁后-destroyed"><a href="#八、销毁后-destroyed" class="headerlink" title="八、销毁后(destroyed)"></a>八、销毁后(destroyed)</h2><ol><li>在实例销毁之后调用，调用后，所有的事件监听器均会被移除，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用。</li></ol><ul><li>总结：vue的生命周期的思想贯穿在组件开发的始终，通过熟悉其生命周期调用不同的钩子函数，我们可以准确的控制数据流和其对DOM的影响；vue生命周期的思想是Vnode和MVVM的生动体现和继承。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>宝塔部署前后端分离Vue项目</title>
    <link href="/2022/08/30/%E5%AE%9D%E5%A1%94%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/08/30/%E5%AE%9D%E5%A1%94%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><ol><li>在云服务器控制台，远程连接实例，在shell命令行中输入:</li></ol><p>&#x2F;etc&#x2F;init.d&#x2F;bt default （默认连接）</p><ol start="2"><li><p>进入宝塔面板网站，输入账号密码，进入宝塔控制台。<a href="https://www.bt.cn/new/download.html">https://www.bt.cn/new/download.html</a></p></li><li><p>在软件商店中下载PM2管理器，安装好之后再设置中选择合适的Node.js版本。</p></li><li><p>在宝塔面板 –&gt; 安全 –&gt;放行端口，放行前端和后端的端口号。</p></li></ol><h2 id="二、导入文件"><a href="#二、导入文件" class="headerlink" title="二、导入文件"></a>二、导入文件</h2><ol start="5"><li><p>通过宝塔面板的文件栏，找到 &#x2F;www&#x2F;wwwroot 目录下，将后端项目压缩包，解压到该目录下。再进入到 &#x2F;www&#x2F;wwwroot&#x2F;http 目录下，将前端项目的dist包，解压到该目录下，即可。</p></li><li><p>温馨提示：dist包可以通过前端项目 npm run build 自动打包生成哦。</p></li><li><p>SQL数据库文件导入，在面版 –&gt; 数据库 –&gt;下载phpMYAdmin（管理MySQL数据库的），点击添加数据库，将自己的数据库文件导入即可。</p></li></ol><h2 id="三、启动后端项目"><a href="#三、启动后端项目" class="headerlink" title="三、启动后端项目"></a>三、启动后端项目</h2><ol start="8"><li><p>在面板 –&gt; 终端中输入 cd &#x2F;www&#x2F;wwwroot&#x2F;后端项目 ，进入后端文件夹，输入：</p></li><li><p>npm start  （运行后端项目）</p></li></ol><p>  就这样，前后端分离Vue项目部署完成了。</p><h2 id="五、可能遇到的问题："><a href="#五、可能遇到的问题：" class="headerlink" title="五、可能遇到的问题："></a>五、可能遇到的问题：</h2><ol start="10"><li>比如端口号占用，可以通过在终端中输入以下命令。</li></ol><p>netstat -nap | grep 3000 （可以查看3000端口的占用情况）。</p><p> kill -9 2048482 （可杀掉占用端口号的进程），其中2048482为占用端口的PID号。</p><ol start="11"><li>再进行启动后端项目的npm start,就可以正常启动后端项目了。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP和HTTPS的基本概念和区别</title>
    <link href="/2022/08/26/htttp%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/08/26/htttp%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="一、HTTP和HTTPS的基本概念"><a href="#一、HTTP和HTTPS的基本概念" class="headerlink" title="一、HTTP和HTTPS的基本概念"></a>一、HTTP和HTTPS的基本概念</h2><p>HTTP（HyperText Transfer Protocol）：超文本（文本、图片、视频、音频、css、js….）传输协议 ，它是基于请求&#x2F;响应模式、应用层（TCP&#x2F;IP协议）、无状态（没有记忆功能）的协议。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。</p><p>HTTP协议的通信过程(工作原理)？</p><p>第一步：客户端与服务器创建连接；</p><p>第二步：客户端发送请求给服务器；</p><p>第三步：服务接收处理请求并返回响应给客户端；</p><p>第四步：客户端与服务器自动断开连接；</p><p>HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer）：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP&#x2F;IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p><h2 id="二、HTTPS协议的通信过程-工作原理-？​​​​​​​​​​​​"><a href="#二、HTTPS协议的通信过程-工作原理-？​​​​​​​​​​​​" class="headerlink" title="二、HTTPS协议的通信过程(工作原理)？​​​​​​​​​​​​"></a>二、HTTPS协议的通信过程(工作原理)？​​​​​​​​​​​​</h2><p>(1)首先客户端向服务端发起一个随机值，以及一个加密算法，<br>   服务端收到后返回一个协商好的加密算法，以及另一个随机值。</p><p>(2)服务端在发送一个公钥CA。</p><p>(3)客户端收到以后先验证CA是否有效，如果无效则报错弹窗，有过有效则进行下一步操作。</p><p>(4)客户端使用之前的两个随机值和一个预主密钥组成一个会话密钥，在通过服务端传来的公钥加密把会话密钥发送给服务端。</p><p>(5)服务端收到后使用私钥解密，得到两个随机值和预主密钥，然后组装成会话密钥。</p><p>(6)客户端在向服务端发起一条信息，这条信息使用会话秘钥加密，用来验证服务端时候能收到加密的信息。</p><p>(7)服务端收到信息后返回一个会话秘钥加密的信息。</p><p>(8)都收到以后SSL层连接建立成功。</p><h2 id="三、既然有了HTTP又为什么要有HTTPS？（HTTPS的设计目标）"><a href="#三、既然有了HTTP又为什么要有HTTPS？（HTTPS的设计目标）" class="headerlink" title="三、既然有了HTTP又为什么要有HTTPS？（HTTPS的设计目标）"></a>三、既然有了HTTP又为什么要有HTTPS？（HTTPS的设计目标）</h2><p>(1) 数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。</p><p>(2) 数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。</p><p>(3) 身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。</p><h2 id="四、HTTP-与-HTTPS-的区别"><a href="#四、HTTP-与-HTTPS-的区别" class="headerlink" title="四、HTTP 与 HTTPS  的区别"></a>四、HTTP 与 HTTPS  的区别</h2><p>1、HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)</p><p>2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</p><p>3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何更换Hexo主题</title>
    <link href="/2022/08/26/Hexo%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2/"/>
    <url>/2022/08/26/Hexo%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="一，下载存放主题："><a href="#一，下载存放主题：" class="headerlink" title="一，下载存放主题："></a>一，下载存放主题：</h2><p>第一步：到hexo官网下载hexo主题包（压缩包一般存储在GitHub上）。</p><ol><li>把压缩包解压到博客系统的文件夹themes。（我的是 E:&#x2F;blog&#x2F;themes）</li></ol><h2 id="第二步：使用node更换主题"><a href="#第二步：使用node更换主题" class="headerlink" title="第二步：使用node更换主题"></a>第二步：使用node更换主题</h2><ol start="2"><li>使用nond控制栏工具，进入到我们Hexo的安装包下面。我的hexo主题放在E盘的blog中。因此，我输入下述代码</li></ol><p>$ E： （先是进入E盘）<br>$ cd blog  （再进入blog）</p><h2 id="第三步：修改blog文件下-config-yml文件内容。"><a href="#第三步：修改blog文件下-config-yml文件内容。" class="headerlink" title="第三步：修改blog文件下_config.yml文件内容。"></a>第三步：修改blog文件下_config.yml文件内容。</h2><ol start="3"><li>在我们hexo安装包中找到_config.yml安装包，用编译器打开（vscode或者sublime）。<br>command + F 查找 theme将原来默认的主题 landscape 改为 下载的文件夹名称（hexo-theme-nexmoe-master）。修改好的代码参考以下：</li></ol><h2 id="theme-hexo-theme-nexmoe-master"><a href="#theme-hexo-theme-nexmoe-master" class="headerlink" title="theme: hexo-theme-nexmoe-master"></a>theme: hexo-theme-nexmoe-master</h2><h2 id="第四步：预览效果！"><a href="#第四步：预览效果！" class="headerlink" title="第四步：预览效果！"></a>第四步：预览效果！</h2><p>接下来，我们先来预览一下，我们主题更换的效果</p><p>$ hexo s  （重启服务器）</p><p>复制浏览器打开生成的链接就可以看到效果了！<br>到这一步，我们基本上上完成了，主题的更换。</p><p>最后，<br>总结</p><p>纸上得来终觉浅，绝知此事要躬行！<br>多敲代码，多动脑子！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用node—键创建博客</title>
    <link href="/2022/08/24/%E4%BD%BF%E7%94%A8node%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/08/24/%E4%BD%BF%E7%94%A8node%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="一-安装hexo框架"><a href="#一-安装hexo框架" class="headerlink" title="一.安装hexo框架"></a>一.安装hexo框架</h2><ol><li><p>安装node.js</p></li><li><p>管理员身份启动命令行</p></li><li><p>node -v  #查看node版本 （最好是用14或者以上的版本）</p></li><li><p>npm -v  #查看npm版本 </p></li><li><p>npm install -g cnpm –registry&#x3D;<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a>  #安装淘宝的cnpm 管理器</p></li><li><p>cnpm -v  #查看cnpm版本</p></li><li><p>cnpm install -g hexo-cli  #安装hexo框架</p></li><li><p>hexo -v  #查看hexo版本</p></li><li><p>mkdir blog  #创建blog目录</p></li><li><p>cd blog  #进入blog目录</p></li><li><h2 id="二-初始化博客"><a href="#二-初始化博客" class="headerlink" title="二.初始化博客"></a>二.初始化博客</h2></li><li><p>hexo init  #生成博客 初始化博客（如果windows系统创建失败，可以现用管理员身份在C:\Windows\System32中创建文件夹，之后再转移到别的文件夹中）</p></li><li><p>hexo s  #启动本地博客服务</p></li><li><p><a href="http://localhost:4000/">http://localhost:4000/</a> #本地访问地址</p></li><li><p>hexo new “我的第一篇文章的名字” #创建新的文章</p></li><li><p>hexo clean  #清理blog文件夹缓存</p></li><li><p>hexo g  #生成</p></li><li><p>hexo s  #生成本地服务器，复制链接可以在本电脑浏览博客。</p></li><li><h2 id="二-上传部署博客"><a href="#二-上传部署博客" class="headerlink" title="二.上传部署博客"></a>二.上传部署博客</h2></li><li><p>在Github创建一个新的仓库 YourGithubName.github.io (前缀名必须是你用户名，后缀必须是.github.io)</p></li><li><p>cnpm install –save hexo-deployer-git  #在blog目录下安装git部署插件</p></li><li><p>hexo c #清理一下</p></li><li><p>hexo g #生成</p></li><li><p>hexo d #部署到远程Github仓库</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 说明书</title>
    <link href="/2022/08/24/hello-hexo/"/>
    <url>/2022/08/24/hello-hexo/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>tags</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>categories</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>link</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>Telescope</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<div class="container">   <div class="section-title center">     <h2>基本 <strong>资料</strong></h2>     <hr>     </div>   <div class="space"></div>   <div class="row">     <div class="col-md-3 col-sm-6 service"> <i class="fa fa-laptop"></i>       <h4><strong>个人信息</strong></h4>       <p>    英文名: Telescope &nbsp; <br />    籍贯：中国    </p>     </div>     <div class="col-md-3 col-sm-6 service"> <i class="fa fa-code"></i>       <h4><strong>专业学历</strong></h4>  <p>        专业：室内设计<br />         学历：专科<br />    </p>     </div>     <div class="col-md-3 col-sm-6 service"> <i class="fa fa-rocket"></i>       <h4><strong>毕业学校</strong></h4>  <p>      学习技能：#css/html  #js  #vue      </p>     </div>    <div class="col-md-3 col-sm-6 service"> <i class="fa fa-bullseye"></i>       <h4><strong>联系方式</strong></h4>       <p>邮箱：168866@163.com</p><br/>     </div>   </div> </div>]]></content>
    
  </entry>
  
  
  
</search>
